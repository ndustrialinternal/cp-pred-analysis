<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Nsight Predictions vs Actual Peaks</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body { 
      font-family: Arial, sans-serif; 
      background-color: #f5f5f5; 
      color: #333;
      display: flex;
      min-height: 100vh;
    }

    /* Navigation Sidebar */
    .sidebar {
      width: 250px;
      background: linear-gradient(135deg, #8DB843 0%, #6B9532 100%);
      color: white;
      position: fixed;
      height: 100vh;
      left: 0;
      top: 0;
      box-shadow: 2px 0 10px rgba(0,0,0,0.1);
      z-index: 1000;
      overflow-y: auto;
    }

    .sidebar-header {
      padding: 1.5rem 1rem;
      border-bottom: 1px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.1);
    }

    .sidebar-title {
      font-size: 1.1rem;
      font-weight: bold;
      color: white;
      text-decoration: none;
    }

    .nav-menu {
      padding: 1rem 0;
    }

    .nav-item {
      display: block;
      padding: 0.75rem 1.5rem;
      color: rgba(255,255,255,0.9);
      text-decoration: none;
      transition: all 0.3s ease;
      border-left: 3px solid transparent;
    }

    .nav-item:hover {
      background: rgba(255,255,255,0.1);
      color: white;
      border-left-color: #fff;
    }

    .nav-item.active {
      background: rgba(255,255,255,0.15);
      color: white;
      border-left-color: #fff;
      font-weight: 500;
    }

    /* Main Content */
    .main-content {
      margin-left: 250px;
      padding: 2rem;
      width: calc(100% - 250px);
    }

    h1 { 
      color: #495057;
      font-weight: 600;
      margin-bottom: 1rem;
      text-align: center;
    }

    #legend { 
      margin: 1rem 0; 
      font-size: 0.9rem;
      text-align: center;
      padding: 1rem;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    #legend span { 
      display: inline-block; 
      width: 1rem; 
      height: 1rem; 
      background: #fffa8b; 
      border: 1px solid #e0e0e0; 
      margin-right: 0.5rem; 
      vertical-align: middle; 
    }

    #legend .prob { 
      display: inline-block; 
      width: 1rem; 
      height: 1rem; 
      border: 2px solid #D63031; 
      margin-right: 0.5rem; 
      vertical-align: middle; 
    }

    /* Controls Section */
    .controls-section {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    #controls { 
      display: flex; 
      gap: 1.5rem; 
      align-items: center; 
      flex-wrap: wrap; 
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .control-group label { 
      font-size: 0.9rem;
      font-weight: 500;
      color: #495057;
    }

    .control-input {
      padding: 0.5rem 0.75rem;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: 0.9rem;
      background: #fff;
      color: #495057;
      transition: border-color 0.2s ease;
    }

    .control-input:focus {
      outline: none;
      border-color: #8DB843;
      box-shadow: 0 0 0 2px rgba(141, 184, 67, 0.1);
    }

    .export-buttons {
      display: flex;
      gap: 0.5rem;
      margin-left: auto;
    }

    .export-btn { 
      padding: 0.5rem 1rem; 
      color: white; 
      border: none; 
      border-radius: 6px; 
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .export-btn:hover { 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .export-btn.pjm {
      background: linear-gradient(135deg, #007cba 0%, #005a87 100%);
    }

    .export-btn.ercot {
      background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
    }

    section { 
      margin-top: 2rem; 
      padding: 1.5rem; 
      background: #fff; 
      border: 1px solid #e0e0e0; 
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    section h2 {
      color: #495057;
      font-weight: 600;
      margin-bottom: 1rem;
      font-size: 1.1rem;
    }

    table { 
      width: 100%; 
      border-collapse: collapse; 
      margin: .5rem 0 1.5rem; 
    }

    th, td { 
      padding: .75rem .5rem; 
      border: 1px solid #e0e0e0; 
      text-align: center; 
    }

    th { 
      background: #f8f9fa;
      color: #495057;
      font-weight: 600;
    }

    tr:nth-child(even) {
      background: #f9f9f9;
    }

    tr:hover {
      background: #f0f0f0;
    }

    .high-prob { 
      outline: 2px solid #D63031; 
    }

    .top-actual { 
      background-color: #fffa8b !important; 
    }

    #loading { 
      font-style: italic; 
      color: #6c757d;
      text-align: center;
      padding: 2rem;
    }

    .error { 
      color: #D63031;
      margin-top: .5rem;
      background: #fff5f5;
      border: 1px solid #fecaca;
      border-radius: 6px;
      padding: 1rem;
      text-align: center;
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
        height: auto;
        position: relative;
      }
      
      .main-content {
        margin-left: 0;
        width: 100%;
      }
      
      #controls {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
      }
      
      .control-group {
        width: 100%;
      }
      
      .export-buttons {
        margin-left: 0;
        margin-top: 1rem;
      }
    }
  </style>
</head>
<body>
  <!-- Left Navigation Sidebar -->
  <nav class="sidebar">
    <div class="sidebar-header">
      <a href="#" class="sidebar-title">CP Dashboard</a>
    </div>
    <div class="nav-menu">
      <a href="https://ndustrialinternal.github.io/amp-cp-alerts/" class="nav-item">CP Predictions</a>
      <a href="https://ndustrialinternal.github.io/cp-peaks/" class="nav-item">CP Peaks</a>
      <a href="https://ndustrialinternal.github.io/current-cp-loads/" class="nav-item">Load Profiles</a>
      <a href="https://ndustrialinternal.github.io/cp-pred-analysis/" class="nav-item active">Prediction Analytics</a>
    </div>
  </nav>

  <!-- Main Content -->
  <div class="main-content">
    <h1>Nsight Predictions vs Actual Peaks</h1>
    
    <div id="legend">
      <span></span> Highest Loads (5/month PJM, 1/month ERCOT)
      <span class="prob"></span> Predictions ≥ threshold (outlined in red)
    </div>
    
    <div class="controls-section">
      <div id="controls">
        <div class="control-group">
          <label for="program-selector">Program</label>
          <select id="program-selector" class="control-input">
            <option value="ALL">All</option>
          </select>
        </div>

        <div class="control-group">
          <label for="start-date">Start Date</label>
          <input type="date" id="start-date" class="control-input" />
        </div>

        <div class="control-group">
          <label for="end-date">End Date</label>
          <input type="date" id="end-date" class="control-input" />
        </div>

        <div class="control-group">
          <label for="prob-input">Probability ≥</label>
          <input type="number" id="prob-input" min="0" max="100" step="1" value="93" class="control-input" style="width:5rem;" />
        </div>

        <div class="control-group">
          <label for="day-filter">Day of Week</label>
          <select id="day-filter" class="control-input">
            <option value="ALL">All Days</option>
            <option value="0">Sunday</option>
            <option value="1">Monday</option>
            <option value="2">Tuesday</option>
            <option value="3">Wednesday</option>
            <option value="4">Thursday</option>
            <option value="5">Friday</option>
            <option value="6">Saturday</option>
          </select>
        </div>

        <div class="export-buttons">
          <button id="export-pjm" class="export-btn pjm">Export PJM CSV</button>
          <button id="export-ercot" class="export-btn ercot">Export ERCOT CSV</button>
        </div>
      </div>
    </div>

    <div id="loading">Loading data…</div>
    <div id="error" class="error" style="display:none;"></div>
    <div id="content" style="display:none;"></div>
  </div>

  <script>
    console.log('Script loaded');
    
    // Set default dates immediately
    function setDefaultDates() {
      try {
        const today = new Date();
        const previousMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        const lastDayPrevMonth = new Date(today.getFullYear(), today.getMonth(), 0);
        
        const startDate = previousMonth.toISOString().slice(0, 10);
        const endDate = lastDayPrevMonth.toISOString().slice(0, 10);
        
        console.log('Setting default dates:', startDate, 'to', endDate);
        
        document.getElementById('start-date').value = startDate;
        document.getElementById('end-date').value = endDate;
        
        console.log('Default dates set successfully');
      } catch (err) {
        console.error('Error setting default dates:', err);
      }
    }
    
    // Call immediately
    setDefaultDates();
    
    // Also set on DOM ready as backup
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setDefaultDates);
    }
    
    console.log('Basic setup complete, now loading Supabase...');
  </script>
  
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js" onload="console.log('Supabase script loaded')" onerror="console.error('Failed to load Supabase script')"></script>
  
  <script>
    console.log('Final script executing...');
    
    function initApp() {
      console.log('InitApp called');
      
      if (typeof supabase === 'undefined') {
        console.error('Supabase is not available');
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').innerHTML = 'Failed to load required libraries. Please refresh the page.';
        document.getElementById('error').style.display = '';
        return;
      }
      
      console.log('Supabase is available, starting main application...');
      
      // Start the actual application
      startApplication();
    }
    
    async function startApplication() {
      try {
        console.log('Starting application...');
        
        // Supabase clients
        const peaksClient = supabase.createClient(
          'https://univbemvihlcincvqwpz.supabase.co',
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVuaXZiZW12aWhsY2luY3Zxd3B6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA5NjM1MzYsImV4cCI6MjA2NjUzOTUzNn0.qLq66dTzf_ATHfBDKyRU5PIwKX5Sj0-2yP-1ceFFAzM'
        );
        const loadsClient = supabase.createClient(
          'https://jlmdkdeyemtbuoqzhmnk.supabase.co',
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpsbWRrZGV5ZW10YnVvcXpobW5rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzODczNzUsImV4cCI6MjA2ODk2MzM3NX0.D67p_so_Tkok6wCAt4_2w6xqVcrEC9wYnyohe0E7huc'
        );

        console.log('Supabase clients created');

        // Programs + zone codes mapping
        const sources = [
          { key:'peak_snapshots_pjm_5cp_plc',              label:'PJM RTO',    zone:'RTO',    type:'pjm' },
          { key:'peak_snapshots_pjm_5cp_nits_pjm_lz_aeco', label:'AECO',       zone:'AE',     type:'pjm' },
          { key:'peak_snapshots_pjm_5cp_nits_pjm_lz_aep',  label:'AEP',        zone:'AEP',    type:'pjm' },
          { key:'peak_snapshots_pjm_5cp_nits_pjm_lz_bge',  label:'BGE',        zone:'BC',     type:'pjm' },
          { key:'peak_snapshots_pjm_5cp_nits_pjm_lz_comed',label:'COMED',      zone:'CE',     type:'pjm' },
          { key:'peak_snapshots_pjm_5cp_nits_pjm_lz_dpl',  label:'DPL',        zone:'DPL',    type:'pjm' },
          { key:'peak_snapshots_pjm_5cp_nits_pjm_lz_peco', label:'PECO',       zone:'PE',     type:'pjm' },
          { key:'peak_snapshots_pjm_5cp_nits_pjm_lz_ppl',  label:'PPL',        zone:'PL',     type:'pjm' },
          { key:'peak_snapshots_pjm_5cp_nits_pjm_lz_pseg', label:'PSEG',       zone:'PS',     type:'pjm' },
          { key:'peak_snapshots_ercot_4cp',                label:'ERCOT 4CP',  zone:'ERCOT', type:'ercot' }
        ];

        // Populate program selector
        const progSel = document.getElementById('program-selector');
        sources.forEach(s => {
          const o = document.createElement('option');
          o.value = s.key;
          o.text  = s.label;
          progSel.add(o);
        });

        console.log('Program selector populated');

        // Fetch predictions data
        console.log('=== FETCHING PREDICTIONS ===');
        const allPreds = {};
        
        for (const s of sources) {
          console.log(`Fetching predictions for ${s.label}...`);
          const { data, error } = await peaksClient
            .from(s.key)
            .select('captured_at, day_0_peak_hour, day_0_peak_load, day_0_probability')
            .order('captured_at');
          
          if (error) {
            console.error(`Error fetching ${s.label}:`, error);
            throw error;
          }
          
          allPreds[s.key] = data || [];
          console.log(`${s.label} predictions:`, data?.length || 0, 'rows');
        }

        console.log('All predictions fetched successfully');

        // Get date range from the default dates we already set
        const startDate = document.getElementById('start-date').value;
        const endDate = document.getElementById('end-date').value;

        console.log('Using date range:', startDate, 'to', endDate);

        // Fetch PJM actual data
        console.log('=== FETCHING PJM DATA ===');
        const { data: pjmData, error: pjmErr } = await loadsClient
          .from('pjm_daily_max')
          .select('interval_start_utc, zone, mw')
          .gte('interval_start_utc', `${startDate} 00:00:00+00`)
          .lte('interval_start_utc', `${endDate} 23:59:59+00`)
          .order('interval_start_utc');
        
        if (pjmErr) {
          console.error('PJM data error:', pjmErr);
          throw pjmErr;
        }
        
        console.log('PJM data fetched:', pjmData?.length || 0, 'rows');

        // Fetch ERCOT actual data
        console.log('=== FETCHING ERCOT DATA ===');
        const { data: ercotData, error: ercErr } = await loadsClient
          .from('ercot_daily_max')
          .select('interval_start_local, cp')
          .gte('interval_start_local', `${startDate} 00:00:00`)
          .lte('interval_start_local', `${endDate} 23:59:59`)
          .order('interval_start_local');
        
        if (ercErr) {
          console.error('ERCOT data error:', ercErr);
          throw ercErr;
        }
        
        console.log('ERCOT data fetched:', ercotData?.length || 0, 'rows');

        // Process the data and create data maps (simplified for now)
        const pjmMap = {};
        const ercotMap = {};

        // Process PJM data
        if (pjmData && Array.isArray(pjmData)) {
          pjmData.forEach((e, index) => {
            try {
              if (!e || !e.interval_start_utc) return;
              
              const timestamp = e.interval_start_utc;
              let utcDate;
              if (timestamp.includes('T')) {
                utcDate = new Date(timestamp);
              } else {
                utcDate = new Date(timestamp.replace(' ', 'T'));
              }
              
              const hourEndDate = new Date(utcDate.getTime() + 60 * 60 * 1000);
              const etDate = utcDate.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
              
              pjmMap[etDate] = pjmMap[etDate] || {};
              pjmMap[etDate][e.zone] = { 
                time: hourEndDate,
                mw: parseFloat(e.mw)
              };
            } catch (err) {
              console.error(`Error processing PJM row ${index}:`, err);
            }
          });
        }

        // Process ERCOT data
        if (ercotData && Array.isArray(ercotData)) {
          ercotData.forEach((e, index) => {
            try {
              if (!e || !e.interval_start_local) return;
              
              const timestamp = e.interval_start_local;
              const ctDate = timestamp.slice(0, 10);
              
              let localDate;
              if (timestamp.includes('T')) {
                const isoString = timestamp.replace(/[+-]\d{2}:\d{2}$/, '');
                localDate = new Date(isoString + '-05:00');
              } else {
                const isoString = timestamp.replace(' ', 'T');
                localDate = new Date(isoString + '-05:00');
              }
              
              ercotMap[ctDate] = { 
                time: localDate, 
                cp: parseFloat(e.cp) 
              };
            } catch (err) {
              console.error(`Error processing ERCOT row ${index}:`, err);
            }
          });
        }

        console.log('Data processing complete');
        console.log('PJM map has', Object.keys(pjmMap).length, 'dates');
        console.log('ERCOT map has', Object.keys(ercotMap).length, 'dates');

        // Hide loading and show content
        document.getElementById('loading').style.display = 'none';
        document.getElementById('content').style.display = '';

        // Function to identify top actual values (top 5 for PJM zones, top 1 for ERCOT per month)
        function identifyTopActuals(rows, sourceType, zone) {
          if (!rows.length) return new Set();
          
          const topDates = new Set();
          
          // Group by month
          const byMonth = {};
          rows.forEach(r => {
            if (r.actualMW > 0) {
              const month = r.captured_at.slice(0, 7); // YYYY-MM
              byMonth[month] = byMonth[month] || [];
              byMonth[month].push(r);
            }
          });
          
          // For each month, find top values
          Object.values(byMonth).forEach(monthRows => {
            monthRows.sort((a, b) => b.actualMW - a.actualMW);
            const topCount = sourceType === 'ercot' ? 1 : 5;
            const topRows = monthRows.slice(0, topCount);
            topRows.forEach(r => topDates.add(r.captured_at.slice(0, 10)));
          });
          
          return topDates;
        }

        // CSV Export function
        function exportToCSV(data, filename) {
          if (!data || data.length === 0) {
            alert('No data to export');
            return;
          }
          
          const headers = Object.keys(data[0]);
          let csvContent = headers.join(',') + '\n';
          
          data.forEach(row => {
            const values = headers.map(header => {
              let value = row[header];
              if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
                value = '"' + value.replace(/"/g, '""') + '"';
              }
              return value;
            });
            csvContent += values.join(',') + '\n';
          });
          
          const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          const url = URL.createObjectURL(blob);
          link.setAttribute('href', url);
          link.setAttribute('download', filename);
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        // Function to get filtered data for export
        function getFilteredData(sourceType) {
          const start = document.getElementById('start-date').value;
          const end = document.getElementById('end-date').value;
          const dayFilter = document.getElementById('day-filter').value;
          
          const exportData = [];
          
          sources.filter(s => s.type === sourceType).forEach(s => {
            let rows = (allPreds[s.key] || []).filter(r => {
              const d = r.captured_at.slice(0,10);
              const dateMatch = (!start || d >= start) && (!end || d <= end);
              
              if (!dateMatch) return false;
              if (dayFilter === 'ALL') return true;
              
              const date = new Date(d + 'T12:00:00');
              const dayOfWeek = date.getDay();
              return dayOfWeek === parseInt(dayFilter);
            });
            
            // Keep only the last prediction per day
            const lastByDay = {};
            rows.forEach(r => {
              const day = r.captured_at.slice(0,10);
              if (!lastByDay[day] || r.captured_at > lastByDay[day].captured_at) {
                lastByDay[day] = r;
              }
            });
            rows = Object.values(lastByDay).sort((a,b) => new Date(a.captured_at) - new Date(b.captured_at));
            
            rows.forEach(r => {
              const predDate = r.captured_at.slice(0,10);
              
              if (s.type === 'pjm') {
                const actual = (pjmMap[predDate] || {})[s.zone];
                if (actual) {
                  r.actualTime = actual.time;
                  r.actualMW = actual.mw;
                } else {
                  r.actualTime = null;
                  r.actualMW = 0;
                }
              } else {
                const actual = ercotMap[predDate];
                if (actual) {
                  r.actualTime = actual.time;
                  r.actualMW = actual.cp;
                } else {
                  r.actualTime = null;
                  r.actualMW = 0;
                }
              }
              
              const date = new Date(r.captured_at.slice(0,10) + 'T12:00:00');
              const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
              const dayOfWeek = dayNames[date.getDay()];
              
              const predTime = `${String(r.day_0_peak_hour % 12 || 12).padStart(2,'0')}:00 ${r.day_0_peak_hour >= 12 ? 'PM' : 'AM'}`;
              const actualTimeStr = r.actualTime
                ? r.actualTime.toLocaleTimeString('en-US', {
                    hour12: true,
                    hour: '2-digit',
                    minute: '2-digit'
                  })
                : 'No Data';
              
              const predMW = r.day_0_peak_load * 1000;
              const actualMW = r.actualMW || 0;
              const errorMW = actualMW > 0 ? (predMW - actualMW) : null;
              const errorPct = actualMW > 0 ? ((predMW - actualMW) / actualMW * 100) : null;
              
              exportData.push({
                'Zone': s.label,
                'Date': r.captured_at.slice(0,10),
                'Day_of_Week': dayOfWeek,
                'Predicted_Time': predTime,
                'Predicted_Load_MW': predMW,
                'Probability_Percent': r.day_0_probability,
                'Actual_Peak_Time': actualTimeStr,
                'Actual_Peak_Load_MW': actualMW > 0 ? actualMW : 'No Data',
                'Error_MW': errorMW !== null ? errorMW : 'N/A',
                'Error_Percent': errorPct !== null ? parseFloat(errorPct.toFixed(1)) : 'N/A'
              });
            });
          });
          
          return exportData;
        }

        // Main render function
        function render() {
          console.log('=== RENDERING ===');
          const start = document.getElementById('start-date').value;
          const end = document.getElementById('end-date').value;
          const thr = +document.getElementById('prob-input').value;
          const sel = progSel.value;
          const dayFilter = document.getElementById('day-filter').value;
          const cont = document.getElementById('content');
          cont.innerHTML = '';

          sources.forEach(s => {
            if (sel !== 'ALL' && sel !== s.key) return;

            // Filter and keep only last prediction per day
            let rows = (allPreds[s.key] || []).filter(r => {
              const d = r.captured_at.slice(0,10);
              const dateMatch = (!start || d >= start) && (!end || d <= end);
              
              if (!dateMatch) return false;
              if (dayFilter === 'ALL') return true;
              
              const date = new Date(d + 'T12:00:00');
              const dayOfWeek = date.getDay();
              return dayOfWeek === parseInt(dayFilter);
            });
            
            // Keep only the last prediction per day
            const lastByDay = {};
            rows.forEach(r => {
              const day = r.captured_at.slice(0,10);
              if (!lastByDay[day] || r.captured_at > lastByDay[day].captured_at) {
                lastByDay[day] = r;
              }
            });
            rows = Object.values(lastByDay).sort((a,b) => new Date(a.captured_at) - new Date(b.captured_at));
            
            if (!rows.length) return;

            // Attach actuals
            rows.forEach(r => {
              const predDate = r.captured_at.slice(0,10);
              
              if (s.type === 'pjm') {
                const actual = (pjmMap[predDate] || {})[s.zone];
                if (actual) {
                  r.actualTime = actual.time;
                  r.actualMW = actual.mw;
                } else {
                  r.actualTime = null;
                  r.actualMW = 0;
                }
              } else {
                const actual = ercotMap[predDate];
                if (actual) {
                  r.actualTime = actual.time;
                  r.actualMW = actual.cp;
                } else {
                  r.actualTime = null;
                  r.actualMW = 0;
                }
              }
            });

            // Identify top actual values for highlighting
            const topActualDates = identifyTopActuals(rows, s.type, s.zone);

            // Build section/table
            const sec = document.createElement('section');
            const h2 = document.createElement('h2');
            h2.innerText = `${s.label}`;
            sec.appendChild(h2);

            const tbl = document.createElement('table');
            const thead = tbl.createTHead().insertRow();
            [
              'Date',
              'Day',
              'Pred Time (Hour End ET)',
              'Pred Load (MW)',
              'Prob (%)',
              s.type === 'pjm' ? 'Actual Peak Time (ET)' : 'Actual Peak Time (CT)',
              'Actual Peak Load (MW)',
              'Error (MW)',
              'Error %'
            ].forEach(txt => {
              const th = document.createElement('th');
              th.innerText = txt;
              thead.appendChild(th);
            });

            const tbody = tbl.createTBody();
            rows.forEach(r => {
              const tr = tbody.insertRow();
              if (r.day_0_probability >= thr) tr.classList.add('high-prob');
              
              const rowDate = r.captured_at.slice(0, 10);
              if (topActualDates.has(rowDate)) {
                tr.classList.add('top-actual');
              }
              
              const predTime = `${String(r.day_0_peak_hour % 12 || 12).padStart(2,'0')}:00 ${r.day_0_peak_hour >= 12 ? 'PM' : 'AM'}`;
              const actualTimeStr = r.actualTime
                ? r.actualTime.toLocaleTimeString('en-US', {
                    hour12: true,
                    hour: '2-digit',
                    minute: '2-digit'
                  })
                : 'No Data';
              
              const date = new Date(r.captured_at.slice(0,10) + 'T12:00:00');
              const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
              const dayOfWeek = dayNames[date.getDay()];
              
              const predMW = r.day_0_peak_load * 1000;
              const actualMW = r.actualMW || 0;
              const errorMW = actualMW > 0 ? (predMW - actualMW) : null;
              const errorPct = actualMW > 0 ? ((predMW - actualMW) / actualMW * 100) : null;
              
              [
                r.captured_at.slice(0,10),
                dayOfWeek,
                predTime,
                predMW.toLocaleString(),
                r.day_0_probability,
                actualTimeStr,
                actualMW > 0 ? actualMW.toLocaleString() : 'No Data',
                errorMW !== null ? errorMW.toLocaleString() : 'N/A',
                errorPct !== null ? errorPct.toFixed(1) + '%' : 'N/A'
              ].forEach(val => {
                const td = tr.insertCell();
                td.innerText = val;
              });
            });

            sec.appendChild(tbl);
            cont.appendChild(sec);
          });
        }

        // Wire up controls
        ['prob-input', 'start-date', 'end-date', 'day-filter'].forEach(id =>
          document.getElementById(id).addEventListener('change', render)
        );
        progSel.addEventListener('change', render);

        // Wire up export buttons
        document.getElementById('export-pjm').addEventListener('click', () => {
          const data = getFilteredData('pjm');
          const dateStr = new Date().toISOString().slice(0,10);
          exportToCSV(data, `PJM_Predictions_${dateStr}.csv`);
        });

        document.getElementById('export-ercot').addEventListener('click', () => {
          const data = getFilteredData('ercot');
          const dateStr = new Date().toISOString().slice(0,10);
          exportToCSV(data, `ERCOT_Predictions_${dateStr}.csv`);
        });

        // Initial render
        render();

        console.log('Application startup complete');

      } catch (err) {
        console.error('Application error:', err);
        document.getElementById('loading').style.display = 'none';
        const errorEl = document.getElementById('error');
        errorEl.innerHTML = `Error: ${err.message}`;
        errorEl.style.display = '';
      }
    }
    
    // Try to initialize immediately
    if (typeof supabase !== 'undefined') {
      console.log('Supabase already available');
      initApp();
    } else {
      console.log('Waiting for Supabase to load...');
      let attempts = 0;
      const checkSupabase = setInterval(() => {
        attempts++;
        console.log(`Checking for Supabase attempt ${attempts}`);
        
        if (typeof supabase !== 'undefined') {
          console.log('Supabase found!');
          clearInterval(checkSupabase);
          initApp();
        } else if (attempts > 50) {
          console.error('Timeout waiting for Supabase');
          clearInterval(checkSupabase);
          document.getElementById('loading').style.display = 'none';
          document.getElementById('error').innerHTML = 'Failed to load required libraries after timeout. Please refresh the page.';
          document.getElementById('error').style.display = '';
        }
      }, 100);
    }
  </script>
</body>
</html>
